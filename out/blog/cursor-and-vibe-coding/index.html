<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="stylesheet" href="/_next/static/css/b09f3dd199b840c6.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-8658fdbc42bfbbae.js"/><script src="/_next/static/chunks/fd9d1056-749e5812300142af.js" async=""></script><script src="/_next/static/chunks/117-3484a610072bf3f8.js" async=""></script><script src="/_next/static/chunks/main-app-89bf57e9bc5560a3.js" async=""></script><script src="/_next/static/chunks/972-f708ded502b3627d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-d31ec5009b84dc46.js" async=""></script><title>Cursor 한 달간의 사용기와 Vibe Coding - My Blog</title><meta property="og:title" content="Cursor 한 달간의 사용기와 Vibe Coding"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Cursor 한 달간의 사용기와 Vibe Coding"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta http-equiv="Pragma" content="no-cache"/><meta http-equiv="Expires" content="0"/><script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><header class="bg-gray-800 text-white p-4"><div class="container mx-auto flex justify-between items-center"><h1 class="text-xl font-bold"><a href="/" target="_self" class="nav-link">Mistersoh&#x27;s blog</a></h1><nav><ul class="flex space-x-4"><li><a href="/" target="_self" class="nav-link hover:text-gray-300">홈</a></li><li><a href="/blog/" target="_self" class="nav-link hover:text-gray-300">블로그</a></li><li><a href="/resume/" target="_self" class="nav-link hover:text-gray-300">이력서</a></li></ul></nav></div></header><main class="container mx-auto p-4"><div class="max-w-4xl mx-auto"><article><header class="mb-8"><h1 class="text-3xl font-bold mb-2">Cursor 한 달간의 사용기와 Vibe Coding</h1><div class="flex flex-wrap items-center gap-2 mb-4"><span class="text-gray-500">2025년 4월 20일</span><span class="text-gray-300 px-2">•</span><span class="text-gray-500">서원우</span></div><div class="flex flex-wrap gap-2 mb-4"><a href="/tag/Cursor/"><div class="bg-gray-100 px-3 py-1 rounded-2xl text-blue-600 hover:bg-blue-50 text-sm font-medium transition-colors ">Cursor</div></a><a href="/tag/Backend/"><div class="bg-gray-100 px-3 py-1 rounded-2xl text-blue-600 hover:bg-blue-50 text-sm font-medium transition-colors ">Backend</div></a><a href="/tag/Vibe Coding/"><div class="bg-gray-100 px-3 py-1 rounded-2xl text-blue-600 hover:bg-blue-50 text-sm font-medium transition-colors ">Vibe Coding</div></a></div></header><div class="markdown-body prose prose-blue max-w-none"><p>안녕하세요.</p>
<p>펏 포스팅으로는 이 블로그를 만들 때 사용하게 된 Cursor 사용기를 작성하게 되었습니다. 이번 기회에 개발자들 사이에서 화제가 되고 있는 Cursor에 대한 약 한 달간의 사용 후기와, 최근 주목받는 Vibe Coding에 대한 간략한 생각을 공유하고자 합니다.</p>
<h1>Cursor 란?</h1>
<p>Cursor 는 MS가 개발한 VSCode 기반 에디터를 토대로, Cursor Inc.에서 자체 개발한 IDE입니다. 이 IDE는 자체 학습된 AI 모델을 내장하고 있으며, 상황에 맞게 다양한 모델을 선택해 사용할 수 있습니다. 기존의 AI 기반 코딩은 단순히 코드 조각을 복붙해 답변을 얻는 방식이었지만, Cursor의 차별점은 **에이전트(Agent)**가 전체 코드베이스를 분석하여 개발자의 의도와 고려 사항에 맞는 최적의 코드를 제안한다는 점입니다.</p>
<h2>Agent란?</h2>
<p>에이전트는 독립된 환경에서 인간의 개입 없이 결정을 내리고 작업을 수행하는 인공지능을 의미합니다. 이 개념은 20세기 중반 앨런 튜링에 의해 처음 제시되었다고 전해집니다. 기존에 에이전트를 활용할 때 문제시되던 점은</p>
<ul>
<li>강화학습을 위한 데이터, 환경 및 보상 체계 구성</li>
<li>다양한 상황 속에서 결정을 내리기 위한 탐색 및 활용 문제</li>
<li>윤리성과 안정성 문제</li>
<li>자연어 이해의 한계</li>
</ul>
<p>등이 있었습니다.</p>
<h1>셋업 및 사용법</h1>
<p>Cursor는 VSCode 기반으로 개발되어 사용법이 거의 동일합니다. 개발자가 원하는 언어나 프레임워크에 맞는 다양한 확장 기능을 설치해 보다 편리하게 사용할 수 있습니다.</p>
<p>Cursor에서 지원하는 주요 기능들로는</p>
<ul>
<li>AI 기반 자동 완성 기능 제공</li>
<li>자연어로 코드 작성 및 수정 요청 가능</li>
<li>코드베이스 전체를 이해하고 적절한 개선 사항 제안</li>
<li>터미널 명령어를 자연어 기반으로 AI 변환 지원</li>
<li>이미지와 코드의 컨텍스트를 이해하고 코드 작성에 반영</li>
<li>웹 검색 통합으로 최신 정보 활용 가능</li>
</ul>
<p>등등이 있습니다. 일부 기능들은 기존 ChatGPT와 같은 툴을 사용했을 때와 동일하지만, 저는 Cursor만의 최대 장점은 바로 "<strong>코드베이스 전체를 이해하고 적절한 개선 사항 제안</strong>" 받을 수 있다는 점이라고 생각합니다.</p>
<h1>사용 사례</h1>
<p>예를 들어, 레포지토리 셋업 시 Gradle 에러가 발생했을 때, 기존의 AI 도구라면 에러 메시지와 관련 코드를 복사해 답변을 받는 방식이었습니다. 그러나 Cursor의 에이전트는 스스로 코드와 터미널 로그를 분석해 에러 발생 지점을 찾아내고, 해결 방안을 직접 제시하며 디버깅까지 수행했습니다.</p>
<h2>예시 1)</h2>
<p>사용 예시 그 첫번째로, 아래와 같이 레포지토리 셋업을 진행할 때 Gradle로부터 에러가 발생하는 상황입니다. 기존의 AI 도구라면, 에러 메시지와 관련 코드를 복사해 해결 가능해 보이는 코드를 받는 방식이었습니다. 하지만  Cursor의 에이전트는 직접 코드 및 터미널 로그를 분석하여 에러가 발생되는 지점을 찾아 해결 방법을 제시하고, 심지어 스스로 디버깅까지 해주었습니다.</p>
<p><img src="/images/cursor-and-vibe-coding/gradle-error.png" alt="gradle-error.png"></p>
<p>기존에는 에러 발생 지점을 찾고 관련 정보를 검색한 후, 내가 찾은 해결 방법이 현재 상황과 정확히 일치하는지 확인하며 여러 차례 디버깅을 반복해야 했습니다. 그러나 이제는 Agent가 학습된 정보를 기반으로 내 의도와 현재 상황에 맞는 최적의 솔루션을 제공해 주어, 이러한 과정이 훨씬 효율적으로 변했습니다.</p>
<p>이러한 솔루션은 디버깅뿐만 아니라 리팩토링 과정에서도 더욱 빛을 발했습니다. 기존에는 AI가 전체 맥락을 이해하지 못한 채 제공된 코드만을 기반으로 판단하기 때문에 원하는 결과가 나올 때까지 반복적으로 정보를 입력해야 했습니다. 하지만 Cursor를 활용하면 코드베이스를 전체적으로 분석하여 보다 정확한 개선안을 제시해 주어, 불필요한 반복 작업을 줄일 수 있었습니다.</p>
<h2>예시 2)</h2>
<p>또 다른 사용 예시로, 현제 소속된 연구소에서는 모든 업무를 Azure DevOps에 Task로 등록하기로 결정되었습니다. 등록된 Task는 평가에도 반영되므로, 이를 철저히 관리하는 것이 중요해졌습니다. 그러나 개인적으로 Azure DevOps에 Task를 등록하는 과정이 매우 불편하게 느껴졌고, 업무에 집중하다 보니 Task 등록을 깜빡하는 경우도 종종 발생했습니다.</p>
<p>이러한 불편을 해소하기 위해, 작업 중인 화면에서 바로 Task를 등록할 수 있는 스티커 메모 형태의 메모 앱이 있으면 좋겠다는 생각을 하게 되었습니다. 기존에는 이런 앱을 만들기 위해 유사한 솔루션이 있는지 찾아보거나, 직접 개발해야 했습니다. 하지만 앱을 제작하려면 관련 프레임워크와 기술을 습득해야 했고, 이를 업무와 병행하려면 많은 시간을 투자해야 했기에 결국 제작을 포기했을 가능성이 높았습니다.</p>
<p><img src="/images/cursor-and-vibe-coding/azure-task-memo-app.png" alt="azure-task-memo-app.png"></p>
<p>하지만 Cursor를 사용함으로서 Agent에게 원하는 앱의 기능과 요구사항을 설명하기만 하면, 코드가 디렉토리 구조에 맞게 자동으로 생성되었고, 결과물의 퀄리티도 기대 이상이었습니다. 실제로 사용해 보니 매우 유용했고, 같은 랩의 동료들에게도 공유하게 되었습니다. 덕분에 짧은 점심시간을 활용해 여러 사람의 업무 생산성을 높일 수 있었습니다.</p>
<p>이러한 경험을 통해 연구소 내에서 개발에 있어 필요한 업무 툴을 사전 지식 없이도 스크래치부터 빠르게 제작하여 사용해 볼 수 있어, 업무 능률을 올리는 데 매우 좋을 것으로 보입니다.</p>
<h1>Cursor AI 사용 장단점과 사용팁</h1>
<p>Cursor AI를 사용하며 느꼈던 장단점과 사용팁을 정리 해보았습니다.</p>
<h2>장점</h2>
<h3>코드 자동완성 기능이 매우 정확하고 빠름</h3>
<p>Copilot과 비교했을 때, 보다 정확한 코드 예측을 제공하는 경우가 많았습니다. Copilot은 속도가 조금 더 빠른 편이지만 요구사항에 부적합한 코드를 제시하는 경우가 있었습니다.</p>
<h3><strong>에이전트를 통한 코드 제안</strong></h3>
<p>AI 기반 코드 제안이 실제 업무 시간을 단축시켜 주었습니다. 특히 제작해준 템플릿을 기반으로 리팩토링 및 테스트코드를 짜주는 반복 작업에 특히 유용했습니다.</p>
<h3>다양한 모델 선택 가능</h3>
<p>원하는 사양의 모델을 상황에 맞게 선택할 수 있어 최적의 답안을 받을 수 있습니다. 저는 주로 claud 모델을 사용하고 있습니다.</p>
<h3><strong>VSCode와 유사한 인터페이스</strong></h3>
<p>VSCode에 익숙한 개발자라면 학습 곡선이 낮아 빠르게 적응할 수 있습니다.</p>
<h2>단점</h2>
<h3><strong>서버 연결 불안정</strong></h3>
<p>일부 사용자들이 몰리는 시간대에는 에이전트 작동이 원활하지 않을 때가 있었지만, 잠시 후 재시도하면 문제없이 작동했습니다.</p>
<h3>백엔드 관련 기능 개선 필요</h3>
<p>예를 들어, ctrl+click이나 F12를 이용한 go to definition 기능이 다소 느려 직접 검색해야 하는 불편함이 있습니다. 또한, JAVA Spring 관련 디버깅은 Cursor에서 세팅 시 에러가 발생 중이어 IntelliJ를 병행 사용하고 있습니다.</p>
<h3>복잡한 코드에서 부정확한 제안 발생</h3>
<p>신규 코드 작성이나 리팩토링 시 큰 도움이 됩니다. 다만, 모델의 한계 때문인지 과거에 제안했던 코드를 실행시키거나, 대규모로 리팩토링하는 것 같은 무거운 프로젝트에서는 약간의 성능 저하가 발생하여 부정확한 제안을 할 때가 있었습니다.</p>
<h2>실제 사용 팁</h2>
<h3>기능 및 요구사항을 세분화하기</h3>
<p>신규 기능이나 대규모 리팩토링 작업 시 요구 사항을 구체적으로 나누어 에이전트에 전달하면 성능에 큰 무리 없이 정확한 제안을 받을 수 있습니다. 또한, 프로젝트의 기능이나 흐름을 정리하는 데 도움이 됩니다.</p>
<h3>룰 설정 활용하기</h3>
<p>Cursor에서는 cursor rule이라는 모델의 행동을 컨트롤 할 수 있는 기능이 있습니다. 이는 마치 기존의 프롬프트 엔지니어링 중 역할 지정 기법과도 비슷합니다. 여러 팀원이 같은 모델을 사용해도, 코드의 컨벤션이나 작성기법 등은 다를 수 있기 때문에 cursor rule를 동일하게 적용한다면 이를 방지할 수 있습니다. 많은 사용자들이 인증한 cursor rule은 <a href="https://github.com/PatrickJS/awesome-cursorrules">GitHub Repository</a>를 참고해보세요.</p>
<h3><strong>@</strong> 심볼을 사용해 다양한 검색기능을 사용 가능</h3>
<ul>
<li>@Codebase
<ul>
<li>전체 코드베이스를 스캔하여 구조와 관계를 파악 후 답변합니다. 예를 들어, 레거시 코드 분석 시 명령어 (e.g. @codebase를 파악해서 내 코드의 관계와 역할을 머메이드로 시각화해줘)를 통해 시각화가 가능합니다.</li>
</ul>
</li>
<li>@Docs
<ul>
<li>문서의 웹사이트 링크를 참조합니다. 참조한 문서를 바탕으로 Cursor가 작업을 수행해줍니다.</li>
</ul>
</li>
<li>@Web
<ul>
<li>인터넷 검색을 통해 최신 정보를 찾아봅니다. 가끔 부정확하게 검색을 할 때가 있어 참고용으로 사용하면 좋을 것 같습니다.</li>
</ul>
</li>
</ul>
<h1>Vibe Coding에 대한 생각 (사족)</h1>
<p>최근 대두되고 있는 흥미로운 단어는 <strong>Vibe Coding</strong>입니다. Cursor를 사용하면서 이 단어를 언급하지 않을 수가 없어, 개인적인 생각을 담아보겠습니다.</p>
<p><img src="/images/cursor-and-vibe-coding/begging-of-vibe-coding.png" alt="begging-of-vibe-coding.png"></p>
<p>VibeCoding 이라는 단어가 처음 나오게 된 Andrej Karpathy의 글 입니다. 원문을 살펴보면, 이는 새로운 개발 패러다임을 제시하는 것이라기보다는, "거의 타이핑할 필요도 없고", "귀찮아서 그냥 AI가 주는 대로 해버리고", "버그 해결도 AI가 고쳐질 때까지 반복하는" 등, AI 코드 생성 도구를 활용한 코딩 스타일에 대한 자조적인 표현에 가깝습니다.</p>
<p>많은 사람들이 지금까지 AI를 사용한 코딩을 하나의 개념으로 잡으려고 CDD (Chat Driven Development), AI Pair Programming, No-Code, Zero-Code와 같은 용어로 이름을 붙이려 시도했었습니다. 그 중 유독 “Vibe Coding”만이 많은 개발자들에게 공감을 얻으며 화제가 된 이유는, AI에 의존하면서 생기는 문제와 편리함을 동시에 드러내어, 많은 사람이 공감할 수 있었기 때문이었다고 생각합니다. 이를 보여주는 사례로, <a href="https://www.reddit.com/r/ChatGPTCoding/?rdt=59140"><strong>Vibe Coding Manual : r/ChatGPTCoding</strong></a> 같은 밈이 생겨난 것도 흥미로운 점입니다.</p>
<p>AI 기술은 <strong>Cursor</strong>와 같은 강력한 AI 툴을 통해 빠르게 발전하고 있으며, 개발자 생태계에도 거대한 변화를 불러오고 있습니다. 하지만 중요한 것은 <strong>도구 자체가 아니라, 이를 어떻게 활용할지에 대한 개개인의 전략</strong>입니다. 좋은 개발자가 된다는 것은 단순히 빠르고 효율적인 코드를 작성하는 것 이상을 의미합니다. 문제를 정의하고, 최적의 설계를 고민하며, 프로젝트의 방향을 결정하고, 동료들과 원활하게 소통하는 능력이 그 핵심입니다. 이런 요소들은 “Vibe Coding”이 등장하기 전에도 중요한 역량이었으며, 앞으로도 마찬가지일 것입니다.</p>
<p>결국 <strong>Vibe Coding을 단순한 밈으로 받아들일지, 아니면 새로운 개발 방식으로 활용할지는 각자의 선택</strong>입니다. 저에게 있어 Cursor와 함께한 Vibe Coding은 <strong>아이디어는 있었지만 구현이 번거로워 미뤄왔던 것들을 손쉽게 현실화할 수 있도록 도와준 계기</strong>가 되었습니다. 이를 통해 제 인식과 사고방식에도 변화가 생겼음을 느꼈고, 앞으로도 이러한 변화의 흐름 속에서 저만의 방향성을 정해 나가려 합니다.</p>
<h1>마치며</h1>
<p>Cursor 는 개발자의 생산성을 실제로 향상시킬 수 있는 강력한 도구입니다. 특히 반복적인 작업이나 보일러플레이트 코드 작성에서 큰 도움이 됩니다. 다만, AI의 제안을 무작정 수용하기보다는 코드를 이해하고 검증하는 과정이 반드시 필요합니다.</p>
<p>궁극적으로 어떤 목적을 가지고 도구를 사용할 지는 본인이 정하기에 달렸습니다. Cursor는 나의 실수를 바로 잡아 줄 좋은 페어 프로그래머이자, 좋은 방향성을 가이드해 줄 Senior 프로그래머이자, 귀찮은 일을 대신해줄 비서가 될 수 있습니다.</p>
<p>전반적으로 Cursor AI는 현대 개발 환경에서 매우 유용한 도구이며, 지속적인 업데이트를 통해 더욱 발전할 것으로 기대됩니다.</p>
<p>이상으로 Cursor AI에 대한 제 경험과 생각을 공유 드립니다. 여러분의 업무 효율성을 높이는 데 도움이 되길 바라며, 추가 의견이나 질문이 있으시면 언제든지 말씀해 주세요.</p>
</div></article><div class="mt-8 pt-8 border-t"><div class="flex justify-between items-center"><a class="text-blue-600 hover:underline" href="/blog/">← 블로그 목록으로 돌아가기</a><a class="text-blue-600 hover:underline" href="/tag/">태그 목록 보기 →</a></div></div></div></main><footer class="bg-gray-800 text-white p-4 mt-8"><div class="container mx-auto text-center"><p>© <!-- -->2025<!-- --> Mistersoh&#x27;s Blog. All rights reserved.</p></div></footer><script>
          document.addEventListener('DOMContentLoaded', function() {
            // jQuery를 기다림
            if (typeof jQuery !== 'undefined') {
              initNavigation();
            } else {
              // jQuery가 로드될 때까지 기다림
              const checkJQuery = setInterval(function() {
                if (typeof jQuery !== 'undefined') {
                  clearInterval(checkJQuery);
                  initNavigation();
                }
              }, 100);
            }
            
            function initNavigation() {
              const $ = jQuery;
              
              // 모든 내비게이션 링크에 클릭 핸들러 추가
              $('.nav-link').on('click', function(e) {
                // target="_self" 속성이 있는 링크는 기본 동작 유지
                if ($(this).attr('target') === '_self') {
                  return true;
                }
                
                e.preventDefault();
                const href = $(this).attr('href');
                
                // URL 형식 정규화
                let fetchUrl;
                if (href === '/') {
                  fetchUrl = '/index.html';
                } else if (href.endsWith('.html')) {
                  // .html로 끝나는 경우 그대로 사용
                  fetchUrl = href;
                } else {
                  // 슬래시로 끝나는 경우 처리
                  fetchUrl = href.endsWith('/') ? href + 'index.html' : href + '/index.html';
                }
                
                // 히스토리 API로 URL 변경
                history.pushState({}, '', href);
                
                // 페이지 콘텐츠 로드
                $.ajax({
                  url: fetchUrl,
                  type: 'GET',
                  dataType: 'html',
                  success: function(html) {
                    // 새 HTML에서 메인 콘텐츠 추출
                    const $html = $(html);
                    const $newMain = $html.find('main');
                    
                    // 메인 콘텐츠 교체
                    if ($newMain.length) {
                      $('main').html($newMain.html());
                      // 페이지 제목 업데이트
                      const newTitle = $html.filter('title').text();
                      if (newTitle) {
                        document.title = newTitle;
                      }
                    }
                  },
                  error: function() {
                    console.error('페이지 로드 오류');
                    window.location.href = href; // 오류 시 일반 네비게이션으로 대체
                  }
                });
              });
              
              // 브라우저 뒤로/앞으로 버튼 처리
              $(window).on('popstate', function() {
                // 현재 URL에 맞는 페이지 로드
                const currentPath = window.location.pathname;
                let fetchUrl;
                
                if (currentPath === '/') {
                  fetchUrl = '/index.html';
                } else if (currentPath.endsWith('.html')) {
                  // .html로 끝나는 경우 그대로 사용
                  fetchUrl = currentPath;
                } else {
                  fetchUrl = currentPath.endsWith('/') ? currentPath + 'index.html' : currentPath + '/index.html';
                }
                
                $.ajax({
                  url: fetchUrl,
                  type: 'GET',
                  dataType: 'html',
                  success: function(html) {
                    const $html = $(html);
                    const $newMain = $html.find('main');
                    
                    if ($newMain.length) {
                      $('main').html($newMain.html());
                      // 페이지 제목 업데이트
                      const newTitle = $html.filter('title').text();
                      if (newTitle) {
                        document.title = newTitle;
                      }
                    }
                  },
                  error: function() {
                    window.location.reload();
                  }
                });
              });
            }
          });
        </script><script src="/_next/static/chunks/webpack-8658fdbc42bfbbae.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/b09f3dd199b840c6.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n7:I[6423,[],\"\"]\na:I[1060,[],\"\"]\n6:[\"slug\",\"cursor-and-vibe-coding\",\"d\"]\n8:T10ea,"])</script><script>self.__next_f.push([1,"\n          document.addEventListener('DOMContentLoaded', function() {\n            // jQuery를 기다림\n            if (typeof jQuery !== 'undefined') {\n              initNavigation();\n            } else {\n              // jQuery가 로드될 때까지 기다림\n              const checkJQuery = setInterval(function() {\n                if (typeof jQuery !== 'undefined') {\n                  clearInterval(checkJQuery);\n                  initNavigation();\n                }\n              }, 100);\n            }\n            \n            function initNavigation() {\n              const $ = jQuery;\n              \n              // 모든 내비게이션 링크에 클릭 핸들러 추가\n              $('.nav-link').on('click', function(e) {\n                // target=\"_self\" 속성이 있는 링크는 기본 동작 유지\n                if ($(this).attr('target') === '_self') {\n                  return true;\n                }\n                \n                e.preventDefault();\n                const href = $(this).attr('href');\n                \n                // URL 형식 정규화\n                let fetchUrl;\n                if (href === '/') {\n                  fetchUrl = '/index.html';\n                } else if (href.endsWith('.html')) {\n                  // .html로 끝나는 경우 그대로 사용\n                  fetchUrl = href;\n                } else {\n                  // 슬래시로 끝나는 경우 처리\n                  fetchUrl = href.endsWith('/') ? href + 'index.html' : href + '/index.html';\n                }\n                \n                // 히스토리 API로 URL 변경\n                history.pushState({}, '', href);\n                \n                // 페이지 콘텐츠 로드\n                $.ajax({\n                  url: fetchUrl,\n                  type: 'GET',\n                  dataType: 'html',\n                  success: function(html) {\n                    // 새 HTML에서 메인 콘텐츠 추출\n                    const $html = $(html);\n                    const $newMain = $html.find('main');\n                    \n                    // 메인 콘텐츠 교체\n                    if ($newMain.length) {\n                      $('main').html($newMain.html());\n                      // 페이지 제목 업데이트\n                      const newTitle = $html.filter('title').text();\n                      if (newTitle) {\n                        document.title = newTitle;\n                      }\n                    }\n                  },\n                  error: function() {\n                    console.error('페이지 로드 오류');\n                    window.location.href = href; // 오류 시 일반 네비게이션으로 대체\n                  }\n                });\n              });\n              \n              // 브라우저 뒤로/앞으로 버튼 처리\n              $(window).on('popstate', function() {\n                // 현재 URL에 맞는 페이지 로드\n                const currentPath = window.location.pathname;\n                let fetchUrl;\n                \n                if (currentPath === '/') {\n                  fetchUrl = '/index.html';\n                } else if (currentPath.endsWith('.html')) {\n                  // .html로 끝나는 경우 그대로 사용\n                  fetchUrl = currentPath;\n                } else {\n                  fetchUrl = currentPath.endsWith('/') ? currentPath + 'index.html' : currentPath + '/index.html';\n                }\n                \n                $.ajax({\n                  url: fetchUrl,\n                  type: 'GET',\n                  dataType: 'html',\n                  success: function(html) {\n                    const $html = $(html);\n                    const $newMain = $html.find('main');\n                    \n                    if ($newMain.length) {\n                      $('main').html($newMain.html());\n                      // 페이지 제목 업데이트\n                      const newTitle = $html.filter('title').text();\n                      if (newTitle) {\n                        document.title = newTitle;\n                      }\n                    }\n                  },\n                  error: function() {\n                    window.location.reload();\n                  }\n                });\n              });\n            }\n          });\n        "])</script><script>self.__next_f.push([1,"b:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L2\",null,{\"buildId\":\"K9c6bXf-5guMPPdm7mbyJ\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"blog\",\"cursor-and-vibe-coding\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"cursor-and-vibe-coding\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"cursor-and-vibe-coding\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"cursor-and-vibe-coding\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b09f3dd199b840c6.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"meta\",null,{\"httpEquiv\":\"Cache-Control\",\"content\":\"no-cache, no-store, must-revalidate\"}],[\"$\",\"meta\",null,{\"httpEquiv\":\"Pragma\",\"content\":\"no-cache\"}],[\"$\",\"meta\",null,{\"httpEquiv\":\"Expires\",\"content\":\"0\"}],[\"$\",\"meta\",null,{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1.0\"}],[\"$\",\"script\",null,{\"src\":\"https://code.jquery.com/jquery-3.7.1.min.js\",\"integrity\":\"sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=\",\"crossOrigin\":\"anonymous\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"header\",null,{\"className\":\"bg-gray-800 text-white p-4\",\"children\":[\"$\",\"div\",null,{\"className\":\"container mx-auto flex justify-between items-center\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-xl font-bold\",\"children\":[\"$\",\"a\",null,{\"href\":\"/\",\"target\":\"_self\",\"className\":\"nav-link\",\"children\":\"Mistersoh's blog\"}]}],[\"$\",\"nav\",null,{\"children\":[\"$\",\"ul\",null,{\"className\":\"flex space-x-4\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/\",\"target\":\"_self\",\"className\":\"nav-link hover:text-gray-300\",\"children\":\"홈\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/blog/\",\"target\":\"_self\",\"className\":\"nav-link hover:text-gray-300\",\"children\":\"블로그\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"/resume/\",\"target\":\"_self\",\"className\":\"nav-link hover:text-gray-300\",\"children\":\"이력서\"}]}]]}]}]]}]}],[\"$\",\"main\",null,{\"className\":\"container mx-auto p-4\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L7\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}],[\"$\",\"footer\",null,{\"className\":\"bg-gray-800 text-white p-4 mt-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"container mx-auto text-center\",\"children\":[\"$\",\"p\",null,{\"children\":[\"© \",2025,\" Mistersoh's Blog. All rights reserved.\"]}]}]}],[\"$\",\"script\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$8\"}}]]}]]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L9\"],\"globalErrorComponent\":\"$a\",\"missingSlots\":\"$Wb\"}]\n"])</script><script>self.__next_f.push([1,"c:I[2972,[\"972\",\"static/chunks/972-f708ded502b3627d.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-d31ec5009b84dc46.js\"],\"\"]\nd:T3796,"])</script><script>self.__next_f.push([1,"\u003cp\u003e안녕하세요.\u003c/p\u003e\n\u003cp\u003e펏 포스팅으로는 이 블로그를 만들 때 사용하게 된 Cursor 사용기를 작성하게 되었습니다. 이번 기회에 개발자들 사이에서 화제가 되고 있는 Cursor에 대한 약 한 달간의 사용 후기와, 최근 주목받는 Vibe Coding에 대한 간략한 생각을 공유하고자 합니다.\u003c/p\u003e\n\u003ch1\u003eCursor 란?\u003c/h1\u003e\n\u003cp\u003eCursor 는 MS가 개발한 VSCode 기반 에디터를 토대로, Cursor Inc.에서 자체 개발한 IDE입니다. 이 IDE는 자체 학습된 AI 모델을 내장하고 있으며, 상황에 맞게 다양한 모델을 선택해 사용할 수 있습니다. 기존의 AI 기반 코딩은 단순히 코드 조각을 복붙해 답변을 얻는 방식이었지만, Cursor의 차별점은 **에이전트(Agent)**가 전체 코드베이스를 분석하여 개발자의 의도와 고려 사항에 맞는 최적의 코드를 제안한다는 점입니다.\u003c/p\u003e\n\u003ch2\u003eAgent란?\u003c/h2\u003e\n\u003cp\u003e에이전트는 독립된 환경에서 인간의 개입 없이 결정을 내리고 작업을 수행하는 인공지능을 의미합니다. 이 개념은 20세기 중반 앨런 튜링에 의해 처음 제시되었다고 전해집니다. 기존에 에이전트를 활용할 때 문제시되던 점은\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e강화학습을 위한 데이터, 환경 및 보상 체계 구성\u003c/li\u003e\n\u003cli\u003e다양한 상황 속에서 결정을 내리기 위한 탐색 및 활용 문제\u003c/li\u003e\n\u003cli\u003e윤리성과 안정성 문제\u003c/li\u003e\n\u003cli\u003e자연어 이해의 한계\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e등이 있었습니다.\u003c/p\u003e\n\u003ch1\u003e셋업 및 사용법\u003c/h1\u003e\n\u003cp\u003eCursor는 VSCode 기반으로 개발되어 사용법이 거의 동일합니다. 개발자가 원하는 언어나 프레임워크에 맞는 다양한 확장 기능을 설치해 보다 편리하게 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eCursor에서 지원하는 주요 기능들로는\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAI 기반 자동 완성 기능 제공\u003c/li\u003e\n\u003cli\u003e자연어로 코드 작성 및 수정 요청 가능\u003c/li\u003e\n\u003cli\u003e코드베이스 전체를 이해하고 적절한 개선 사항 제안\u003c/li\u003e\n\u003cli\u003e터미널 명령어를 자연어 기반으로 AI 변환 지원\u003c/li\u003e\n\u003cli\u003e이미지와 코드의 컨텍스트를 이해하고 코드 작성에 반영\u003c/li\u003e\n\u003cli\u003e웹 검색 통합으로 최신 정보 활용 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e등등이 있습니다. 일부 기능들은 기존 ChatGPT와 같은 툴을 사용했을 때와 동일하지만, 저는 Cursor만의 최대 장점은 바로 \"\u003cstrong\u003e코드베이스 전체를 이해하고 적절한 개선 사항 제안\u003c/strong\u003e\" 받을 수 있다는 점이라고 생각합니다.\u003c/p\u003e\n\u003ch1\u003e사용 사례\u003c/h1\u003e\n\u003cp\u003e예를 들어, 레포지토리 셋업 시 Gradle 에러가 발생했을 때, 기존의 AI 도구라면 에러 메시지와 관련 코드를 복사해 답변을 받는 방식이었습니다. 그러나 Cursor의 에이전트는 스스로 코드와 터미널 로그를 분석해 에러 발생 지점을 찾아내고, 해결 방안을 직접 제시하며 디버깅까지 수행했습니다.\u003c/p\u003e\n\u003ch2\u003e예시 1)\u003c/h2\u003e\n\u003cp\u003e사용 예시 그 첫번째로, 아래와 같이 레포지토리 셋업을 진행할 때 Gradle로부터 에러가 발생하는 상황입니다. 기존의 AI 도구라면, 에러 메시지와 관련 코드를 복사해 해결 가능해 보이는 코드를 받는 방식이었습니다. 하지만  Cursor의 에이전트는 직접 코드 및 터미널 로그를 분석하여 에러가 발생되는 지점을 찾아 해결 방법을 제시하고, 심지어 스스로 디버깅까지 해주었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cursor-and-vibe-coding/gradle-error.png\" alt=\"gradle-error.png\"\u003e\u003c/p\u003e\n\u003cp\u003e기존에는 에러 발생 지점을 찾고 관련 정보를 검색한 후, 내가 찾은 해결 방법이 현재 상황과 정확히 일치하는지 확인하며 여러 차례 디버깅을 반복해야 했습니다. 그러나 이제는 Agent가 학습된 정보를 기반으로 내 의도와 현재 상황에 맞는 최적의 솔루션을 제공해 주어, 이러한 과정이 훨씬 효율적으로 변했습니다.\u003c/p\u003e\n\u003cp\u003e이러한 솔루션은 디버깅뿐만 아니라 리팩토링 과정에서도 더욱 빛을 발했습니다. 기존에는 AI가 전체 맥락을 이해하지 못한 채 제공된 코드만을 기반으로 판단하기 때문에 원하는 결과가 나올 때까지 반복적으로 정보를 입력해야 했습니다. 하지만 Cursor를 활용하면 코드베이스를 전체적으로 분석하여 보다 정확한 개선안을 제시해 주어, 불필요한 반복 작업을 줄일 수 있었습니다.\u003c/p\u003e\n\u003ch2\u003e예시 2)\u003c/h2\u003e\n\u003cp\u003e또 다른 사용 예시로, 현제 소속된 연구소에서는 모든 업무를 Azure DevOps에 Task로 등록하기로 결정되었습니다. 등록된 Task는 평가에도 반영되므로, 이를 철저히 관리하는 것이 중요해졌습니다. 그러나 개인적으로 Azure DevOps에 Task를 등록하는 과정이 매우 불편하게 느껴졌고, 업무에 집중하다 보니 Task 등록을 깜빡하는 경우도 종종 발생했습니다.\u003c/p\u003e\n\u003cp\u003e이러한 불편을 해소하기 위해, 작업 중인 화면에서 바로 Task를 등록할 수 있는 스티커 메모 형태의 메모 앱이 있으면 좋겠다는 생각을 하게 되었습니다. 기존에는 이런 앱을 만들기 위해 유사한 솔루션이 있는지 찾아보거나, 직접 개발해야 했습니다. 하지만 앱을 제작하려면 관련 프레임워크와 기술을 습득해야 했고, 이를 업무와 병행하려면 많은 시간을 투자해야 했기에 결국 제작을 포기했을 가능성이 높았습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cursor-and-vibe-coding/azure-task-memo-app.png\" alt=\"azure-task-memo-app.png\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 Cursor를 사용함으로서 Agent에게 원하는 앱의 기능과 요구사항을 설명하기만 하면, 코드가 디렉토리 구조에 맞게 자동으로 생성되었고, 결과물의 퀄리티도 기대 이상이었습니다. 실제로 사용해 보니 매우 유용했고, 같은 랩의 동료들에게도 공유하게 되었습니다. 덕분에 짧은 점심시간을 활용해 여러 사람의 업무 생산성을 높일 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e이러한 경험을 통해 연구소 내에서 개발에 있어 필요한 업무 툴을 사전 지식 없이도 스크래치부터 빠르게 제작하여 사용해 볼 수 있어, 업무 능률을 올리는 데 매우 좋을 것으로 보입니다.\u003c/p\u003e\n\u003ch1\u003eCursor AI 사용 장단점과 사용팁\u003c/h1\u003e\n\u003cp\u003eCursor AI를 사용하며 느꼈던 장단점과 사용팁을 정리 해보았습니다.\u003c/p\u003e\n\u003ch2\u003e장점\u003c/h2\u003e\n\u003ch3\u003e코드 자동완성 기능이 매우 정확하고 빠름\u003c/h3\u003e\n\u003cp\u003eCopilot과 비교했을 때, 보다 정확한 코드 예측을 제공하는 경우가 많았습니다. Copilot은 속도가 조금 더 빠른 편이지만 요구사항에 부적합한 코드를 제시하는 경우가 있었습니다.\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e에이전트를 통한 코드 제안\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eAI 기반 코드 제안이 실제 업무 시간을 단축시켜 주었습니다. 특히 제작해준 템플릿을 기반으로 리팩토링 및 테스트코드를 짜주는 반복 작업에 특히 유용했습니다.\u003c/p\u003e\n\u003ch3\u003e다양한 모델 선택 가능\u003c/h3\u003e\n\u003cp\u003e원하는 사양의 모델을 상황에 맞게 선택할 수 있어 최적의 답안을 받을 수 있습니다. 저는 주로 claud 모델을 사용하고 있습니다.\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003eVSCode와 유사한 인터페이스\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eVSCode에 익숙한 개발자라면 학습 곡선이 낮아 빠르게 적응할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003ch3\u003e\u003cstrong\u003e서버 연결 불안정\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e일부 사용자들이 몰리는 시간대에는 에이전트 작동이 원활하지 않을 때가 있었지만, 잠시 후 재시도하면 문제없이 작동했습니다.\u003c/p\u003e\n\u003ch3\u003e백엔드 관련 기능 개선 필요\u003c/h3\u003e\n\u003cp\u003e예를 들어, ctrl+click이나 F12를 이용한 go to definition 기능이 다소 느려 직접 검색해야 하는 불편함이 있습니다. 또한, JAVA Spring 관련 디버깅은 Cursor에서 세팅 시 에러가 발생 중이어 IntelliJ를 병행 사용하고 있습니다.\u003c/p\u003e\n\u003ch3\u003e복잡한 코드에서 부정확한 제안 발생\u003c/h3\u003e\n\u003cp\u003e신규 코드 작성이나 리팩토링 시 큰 도움이 됩니다. 다만, 모델의 한계 때문인지 과거에 제안했던 코드를 실행시키거나, 대규모로 리팩토링하는 것 같은 무거운 프로젝트에서는 약간의 성능 저하가 발생하여 부정확한 제안을 할 때가 있었습니다.\u003c/p\u003e\n\u003ch2\u003e실제 사용 팁\u003c/h2\u003e\n\u003ch3\u003e기능 및 요구사항을 세분화하기\u003c/h3\u003e\n\u003cp\u003e신규 기능이나 대규모 리팩토링 작업 시 요구 사항을 구체적으로 나누어 에이전트에 전달하면 성능에 큰 무리 없이 정확한 제안을 받을 수 있습니다. 또한, 프로젝트의 기능이나 흐름을 정리하는 데 도움이 됩니다.\u003c/p\u003e\n\u003ch3\u003e룰 설정 활용하기\u003c/h3\u003e\n\u003cp\u003eCursor에서는 cursor rule이라는 모델의 행동을 컨트롤 할 수 있는 기능이 있습니다. 이는 마치 기존의 프롬프트 엔지니어링 중 역할 지정 기법과도 비슷합니다. 여러 팀원이 같은 모델을 사용해도, 코드의 컨벤션이나 작성기법 등은 다를 수 있기 때문에 cursor rule를 동일하게 적용한다면 이를 방지할 수 있습니다. 많은 사용자들이 인증한 cursor rule은 \u003ca href=\"https://github.com/PatrickJS/awesome-cursorrules\"\u003eGitHub Repository\u003c/a\u003e를 참고해보세요.\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e@\u003c/strong\u003e 심볼을 사용해 다양한 검색기능을 사용 가능\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e@Codebase\n\u003cul\u003e\n\u003cli\u003e전체 코드베이스를 스캔하여 구조와 관계를 파악 후 답변합니다. 예를 들어, 레거시 코드 분석 시 명령어 (e.g. @codebase를 파악해서 내 코드의 관계와 역할을 머메이드로 시각화해줘)를 통해 시각화가 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e@Docs\n\u003cul\u003e\n\u003cli\u003e문서의 웹사이트 링크를 참조합니다. 참조한 문서를 바탕으로 Cursor가 작업을 수행해줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e@Web\n\u003cul\u003e\n\u003cli\u003e인터넷 검색을 통해 최신 정보를 찾아봅니다. 가끔 부정확하게 검색을 할 때가 있어 참고용으로 사용하면 좋을 것 같습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eVibe Coding에 대한 생각 (사족)\u003c/h1\u003e\n\u003cp\u003e최근 대두되고 있는 흥미로운 단어는 \u003cstrong\u003eVibe Coding\u003c/strong\u003e입니다. Cursor를 사용하면서 이 단어를 언급하지 않을 수가 없어, 개인적인 생각을 담아보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cursor-and-vibe-coding/begging-of-vibe-coding.png\" alt=\"begging-of-vibe-coding.png\"\u003e\u003c/p\u003e\n\u003cp\u003eVibeCoding 이라는 단어가 처음 나오게 된 Andrej Karpathy의 글 입니다. 원문을 살펴보면, 이는 새로운 개발 패러다임을 제시하는 것이라기보다는, \"거의 타이핑할 필요도 없고\", \"귀찮아서 그냥 AI가 주는 대로 해버리고\", \"버그 해결도 AI가 고쳐질 때까지 반복하는\" 등, AI 코드 생성 도구를 활용한 코딩 스타일에 대한 자조적인 표현에 가깝습니다.\u003c/p\u003e\n\u003cp\u003e많은 사람들이 지금까지 AI를 사용한 코딩을 하나의 개념으로 잡으려고 CDD (Chat Driven Development), AI Pair Programming, No-Code, Zero-Code와 같은 용어로 이름을 붙이려 시도했었습니다. 그 중 유독 “Vibe Coding”만이 많은 개발자들에게 공감을 얻으며 화제가 된 이유는, AI에 의존하면서 생기는 문제와 편리함을 동시에 드러내어, 많은 사람이 공감할 수 있었기 때문이었다고 생각합니다. 이를 보여주는 사례로, \u003ca href=\"https://www.reddit.com/r/ChatGPTCoding/?rdt=59140\"\u003e\u003cstrong\u003eVibe Coding Manual : r/ChatGPTCoding\u003c/strong\u003e\u003c/a\u003e 같은 밈이 생겨난 것도 흥미로운 점입니다.\u003c/p\u003e\n\u003cp\u003eAI 기술은 \u003cstrong\u003eCursor\u003c/strong\u003e와 같은 강력한 AI 툴을 통해 빠르게 발전하고 있으며, 개발자 생태계에도 거대한 변화를 불러오고 있습니다. 하지만 중요한 것은 \u003cstrong\u003e도구 자체가 아니라, 이를 어떻게 활용할지에 대한 개개인의 전략\u003c/strong\u003e입니다. 좋은 개발자가 된다는 것은 단순히 빠르고 효율적인 코드를 작성하는 것 이상을 의미합니다. 문제를 정의하고, 최적의 설계를 고민하며, 프로젝트의 방향을 결정하고, 동료들과 원활하게 소통하는 능력이 그 핵심입니다. 이런 요소들은 “Vibe Coding”이 등장하기 전에도 중요한 역량이었으며, 앞으로도 마찬가지일 것입니다.\u003c/p\u003e\n\u003cp\u003e결국 \u003cstrong\u003eVibe Coding을 단순한 밈으로 받아들일지, 아니면 새로운 개발 방식으로 활용할지는 각자의 선택\u003c/strong\u003e입니다. 저에게 있어 Cursor와 함께한 Vibe Coding은 \u003cstrong\u003e아이디어는 있었지만 구현이 번거로워 미뤄왔던 것들을 손쉽게 현실화할 수 있도록 도와준 계기\u003c/strong\u003e가 되었습니다. 이를 통해 제 인식과 사고방식에도 변화가 생겼음을 느꼈고, 앞으로도 이러한 변화의 흐름 속에서 저만의 방향성을 정해 나가려 합니다.\u003c/p\u003e\n\u003ch1\u003e마치며\u003c/h1\u003e\n\u003cp\u003eCursor 는 개발자의 생산성을 실제로 향상시킬 수 있는 강력한 도구입니다. 특히 반복적인 작업이나 보일러플레이트 코드 작성에서 큰 도움이 됩니다. 다만, AI의 제안을 무작정 수용하기보다는 코드를 이해하고 검증하는 과정이 반드시 필요합니다.\u003c/p\u003e\n\u003cp\u003e궁극적으로 어떤 목적을 가지고 도구를 사용할 지는 본인이 정하기에 달렸습니다. Cursor는 나의 실수를 바로 잡아 줄 좋은 페어 프로그래머이자, 좋은 방향성을 가이드해 줄 Senior 프로그래머이자, 귀찮은 일을 대신해줄 비서가 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e전반적으로 Cursor AI는 현대 개발 환경에서 매우 유용한 도구이며, 지속적인 업데이트를 통해 더욱 발전할 것으로 기대됩니다.\u003c/p\u003e\n\u003cp\u003e이상으로 Cursor AI에 대한 제 경험과 생각을 공유 드립니다. 여러분의 업무 효율성을 높이는 데 도움이 되길 바라며, 추가 의견이나 질문이 있으시면 언제든지 말씀해 주세요.\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"max-w-4xl mx-auto\",\"children\":[[\"$\",\"article\",null,{\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold mb-2\",\"children\":\"Cursor 한 달간의 사용기와 Vibe Coding\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap items-center gap-2 mb-4\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-gray-500\",\"children\":\"2025년 4월 20일\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300 px-2\",\"children\":\"•\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-500\",\"children\":\"서원우\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-4\",\"children\":[[\"$\",\"$Lc\",\"Cursor\",{\"href\":\"/tag/Cursor\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-gray-100 px-3 py-1 rounded-2xl text-blue-600 hover:bg-blue-50 text-sm font-medium transition-colors \",\"children\":\"Cursor\"}]}],[\"$\",\"$Lc\",\"Backend\",{\"href\":\"/tag/Backend\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-gray-100 px-3 py-1 rounded-2xl text-blue-600 hover:bg-blue-50 text-sm font-medium transition-colors \",\"children\":\"Backend\"}]}],[\"$\",\"$Lc\",\"Vibe Coding\",{\"href\":\"/tag/Vibe Coding\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-gray-100 px-3 py-1 rounded-2xl text-blue-600 hover:bg-blue-50 text-sm font-medium transition-colors \",\"children\":\"Vibe Coding\"}]}]]}],\"$undefined\"]}],[\"$\",\"div\",null,{\"className\":\"markdown-body prose prose-blue max-w-none\",\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 pt-8 border-t\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex justify-between items-center\",\"children\":[[\"$\",\"$Lc\",null,{\"href\":\"/blog/\",\"className\":\"text-blue-600 hover:underline\",\"children\":\"← 블로그 목록으로 돌아가기\"}],[\"$\",\"$Lc\",null,{\"href\":\"/tag\",\"className\":\"text-blue-600 hover:underline\",\"children\":\"태그 목록 보기 →\"}]]}]}]]}]\n9:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Cursor 한 달간의 사용기와 Vibe Coding - My Blog\"}],[\"$\",\"meta\""])</script><script>self.__next_f.push([1,",\"3\",{\"property\":\"og:title\",\"content\":\"Cursor 한 달간의 사용기와 Vibe Coding\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"6\",{\"name\":\"twitter:title\",\"content\":\"Cursor 한 달간의 사용기와 Vibe Coding\"}]]\n3:null\n"])</script></body></html>